# 5. 다형성

<br/>
<br/>

## 1) 다형성(Polymorphism)이란?

<br/>

객체 지향 프로그램에서 서로 다른 객체가 동일한 행동을 수행 시키고 싶은 경우가 발생한다. <br/>

<br/>

만약, 자동차 종류를 의미하는 객체인 Sonata, Tiguan, E-class 이렇게 3개가 있다고 가정하자.<br/>
그리고 이 3개의 객체는 모두 run() 이라는 함수를 수행한다.<br/>
그리고 run()이라는 함수는 Car 객체의 멤버 함수다. <br/>

<br/>

이런 구조라면 객체는 일련의 계층형 구조를 형성하게 된다. <br/>

<br/>

![](https://github.com/adrian0220/Study_cpp/blob/main/_src/polymorphism.GIF)

<br/>

개체에서 다르게 활동하지만 전부 다 run이라는 공통의 행동을 가지고 있다. <br/>
각체에서 다른 활동을 각자 객체에 별도로 구현하게 된다면, 다음과 같은 단점이 발생한다. <br/>

<br/>

1. 궁극적으로 같은 행동임에도 불구하고, 각각의 객체에 다른 키워드를 사용해서 정의해야 한다. 키워드 정리가 어렵다.<br/>
2. run()을 수행하는 차량의 종류가 새로 추가될 때 마다 새롭게 객체와 멤버 함수를 정의해야 한다. <br/>

<br/>

위와 같은 단점은 우리의 프로그래밍을 어렵게 한다. <br/>

<br/>

C++ 에서는 이런 문제를 해결하기 위해 가상 함수를 이용한다. <br/>

<br/>
<br/>

## 2) 가상 함수(Virtual Function)

<br/>

가상 함수는 파생되는 클래스에서 재정의해야하는 함수다.<br/>
따라서, 함수의 실체는 파생 클래스에 존재하고, 상위 클래스에서는 함수의 원형만 존재한다. <br/>

<br/>

가상 함수는 virtual 키워드를 사용해 선언하면 된다. <br/>

<br/>

```c++
class Car{
    virtual void Run();
}
```

<br/>

이처럼 상위 클래스에 함수를 선언해준다. <br/>

<br/>

가상 함수를 사용해, 위에서 배운 개념을 적용하면 아래와 같은 코드가 구현된다. <br/>

<br/>

```c++
#include <iostream>
#include <string>
using namespace std;

class Car{
	public:
		virtual void Run() = 0;
};

class Sonata : public Car{
	public:
		virtual void Run(){
			cout <<  "Run Sonata" << endl;
		}
};

class Tiguan : public Car{
	public:
		virtual void Run(){
			cout << "Run Tiguan" << endl;
		}
};

class E_class : public Car{
	public:
		virtual void Run(){
			cout << "Run E_class" << endl;
		}
};

int main() {

	Car* car1 = new Sonata;
	Car* car2 = new Tiguan;
	Car* car3 = new E_class;
	
	car3->Run();
	
	return 0;
}
```

<br/>

__출력 결과++

<br/>

> Run E_clase <br/>

<br/>
