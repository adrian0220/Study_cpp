# 8. 템플릿 클래스

<br/>
<br/>


## 1) 템플릿 함수(Template Function)란?

<br/>

템플릿 함수란 C++에서 함수의 일반화 선언을 의미한다. <br/>
임의의 타입으로 작성된 함수에 특정 타입을 매개변수로 전달하면, <br/>
C++ 컴파일러는 해당 타입에 맞는 함수를 생성해준다. <br/>

<br/>

### 1-1) 템플릿 함수 선언 방법

<br/>

```c++
#include <iostream>
using namespace std;

template <typename T>
void Swap(T& a, T& b);

int main(void)
{
    int a = 2, b = 3;
    cout << "a : " << a << ", b : " << b << endl;
    Swap(a, b);
    cout << "a : " << a << ", b : " << b << endl;
    string name1 = "adrian", name2 = "Lee";
    cout << "name 1 : " << name1 << ", name 2 : " << name2 << endl;
    Swap(name1, name2);
    cout << "name 1 : " << name1 << ", name 2 : " << name2 << endl;

    return 0;
}

template <typename T>
void Swap(T& a, T& b)
{
    T temp;
    temp = a;
    a = b;
    b = temp;
}
```

<br/>

__출력 결과__

<br/>

> a : 2, b : 3 <br/>
> a : 3, b : 2 <br/>
> name 1 : adrian, name 2 : Lee <br/>
> name 1 : Lee, name 2 : adrian <br/>

<br/>

위의 Swap 함수를 보면 템플릿으로 선언 되었음을 알 수 있다. <br/>

<br/>

```c++
template <typename T>
void Swap(T& a, T& b);
```

<br/>

위와 같이 Swap function에 대해 템플릿으로 선언한다. <br/>
이제 함수를 호출하는 시점에서 매개변수를 통해 T에 함수의 타입이 들어가게 된다. <br/>

<br/>

그리고 아래와 같이 함수에 대한 원형을 선언한다. <br/>

<br/>

```c++
template <typename T>
void Swap(T& a, T& b)
{
    T temp;
    temp = a;
    a = b;
    b = temp;
}
```

<br/>

템플릿 타입 T로 temp를 선언한 뒤, 이 변수를 활용하여 a와 b의 값을 바꾼다. <br/>

<br/>

템플릿 함수를 사용하게 되면 알고리즘을 기반으로 하면서 서로 다른 타입에서 동작하는 함수를 한번에 정의할 수 있다. <br/>

<br/>

__템플릿 함수의 동작 원리__

<br/>

1. 함수 템플릿이 각각의 타입에 대해 처음 오출될 때, C++ 컴파일러는 해당 타입의 인스턴스를 생성한다.<br/>
2. 생성된 인스턴스는 해당 타입에 대해 특수화된 템플릿 함수다. <br/>
3. 동일한 타입이 사용 될 때마다 위의 인스턴스가 계속 호출된다. <br/>

<br/>

### 1-2) 명시적 특수화(Explicit Specialization)

<br/>

만약 템플릿 함수를 별도 타입에 대한 특수 로직이 필요한 경우 사용한다. <br/>
컴파일러는 명시적으로 특수화 지정된 타입을 발견하면, 템플릿을 찾지 않고 특수화 정의를 사용한다. <br/>

<br/>

명시적 특수화는 다음과 같이 선언한다. <br/>

```c++
template <> void Swap<double>(double&, double&);
```

<br/>

명시적 특수화로 선언한 함수의 원형은 아래와 같다. <br/>

<br/>

```c++
template <> void Swap<double>(double&, double&)
{
    // double형은 값을 서로 바꾸지 않음.
}
```

<br/>
<br/>

이를 이용해 아래와 같은 프로그램을 만들 수 있다.

<br/>

```c++
#include <iostream>
using namespace std;

template <typename T>
void Swap(T& a, T& b);

template <> void Swap<double>(double&, double&);

int main(void)
{
    int a = 2, b = 3;
    cout << "a : " << a << ", b : " << b << endl;
    Swap(a, b);
    cout << "a : " << a << ", b : " << b << endl;
    string name1 = "adrian", name2 = "Lee";
    cout << "name 1 : " << name1 << ", name 2 : " << name2 << endl;
    Swap(name1, name2);
    cout << "name 1 : " << name1 << ", name 2 : " << name2 << endl;
	double e = 1.234, f = 4.321;
	cout << "e : " << e << ", f : " << f << endl;
	Swap(e, f);
	cout << "e : " << e << ", f : " << f << endl;

    return 0;
}

template <typename T>
void Swap(T& a, T& b)
{
    T temp;
    temp = a;
    a = b;
    b = temp;
}
template <> void Swap<double>(double&, double&)
{
    // double형은 값을 서로 바꾸지 않음.
}
```

<br/>

__실행 결과__

<br/>

> a : 2, b : 3 <br/>
> a : 3, b : 2 <br/>
> name 1 : adrian, name 2 : Lee <br/>
> name 1 : Lee, name 2 : adrian <br/>
> e : 1.234, f : 4.321 <br/>
> e : 1.234, f : 4.321 <br/>

<br/>
<br/>

## 2) 템플릿 클래스(Template Class)란?

<br/>

### 2-1) 개요

<br/>

C++에서 클래스 템플릿(class template)이란 클래스의 일반화된 선언을 의미한다. <br/>
템플릿 클래스는 클래스에 대한 타입을 제너릭으로 선언한 객체를 의미한다. <br/>

<br/>

__템플릿 클래스의 사용__

<br/>

- 타입에 따라 다르게 동작하는 클래스 집합 생성이 가능하다. <br/>
- 클래스 템플릿에 전달된는 템플릿 인수(template argument)에 따라 별도 클래스를 만들 수 있다. <br/>
- 템플릿 인수는 타입이거나 명시된 타입의 상수값이다. <br/>

<br/>
<br/>

### 2-2) 템플릿 클래스의 선언

<br/>

