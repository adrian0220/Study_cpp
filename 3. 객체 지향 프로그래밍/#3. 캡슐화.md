# 3. 추상화

<br/>
<br/>

## 1) 캡슐화(Encapsulation)란?

<br/>

객체지향 프로그래밍에서 캡슐화란 객체에 필요한 변수와 함수를 하나로 묶는 것을 의미한다.<br/>
객체는 기본적으로 멤버 변수와 함수로 이루어져 있는데 이 두가지를 관련성에 따라 하나의 객체로 포함시킨다.<br/>

<br/>

1. 객체의 속성(data fields)과 행위(methods)를 하나로 묶는다. <br/>
2. 실제 구현 내용 일부를 외부에 감추어 은닉한다. <br/>

<br/>

C++의 경우 멤버함수를 호출할 때 객체의 저장공간을 멤버함수에 넘겨 데이터 처리를 하도록 하는 방법을 사용한다.<br/>

<br/>
<br/>

### 캡슐화의 장점

<br/>

캡슐화를 사용한 객체지향 프로그래밍은 아래의 장점을 가지고 있다.<br/>

<br/>

__1. 사용하기 쉽고 프로그램의 복잡성을 줄여준다__

<br/>

캡슐화된 객체를 사용한다면, 사용자는 객체의 public 변수, 함수만 가지고 객체의 활동을 제어한다. <br/>
객체 내부의 로직에 크게 관심을 갖지 않더라도, 함수의 변수들만 잘 선언해주면 쉽게 프로그래밍을 할 수 있다. <br/>
프로그래밍에 필요한 다양한 로직을 객체 안에 담아 좀더 프로그래밍을 단순화 시킨다. <br/>

<br/>

__2. 데이터를 보호하고 오용을 방지한다__

<br/>

private하게 선언된 변수는 아무나 접근할 수 없다. <br/>
이 점을 활용한다면, 사용자의 불필요한 데이터 사용일 방지한다. <br/>

<br/>
<br/>

### 캡슐화 예제

<br/>
 
```c++
#include <iostream>
#include <string>
using namespace std;

class France
{
	private:
		string capital;
		int code;
		string landmark = "Effel Tower";
	
	public:
	    France(string capital, int code)
	    {
	    	this->capital = capital;
	    	this->code = code;
	    }
	    void getCapital(){
	    	cout << capital << endl;
	    }
	    void getLandmark(){
	    	cout << landmark << endl;
	    }
};

class Germany
{
	private:
		string capital;
		int code;
		string leader = "Merkel";
	
	public:
	    Germany(string capital, int code)
	    {
	    	this->capital = capital;
	    	this->code = code;
	    }
	    void getCapital(){
	    	cout << capital << endl;
	    }
	    void getLeader(){
	    	cout << leader << endl;
	    }
};

class England
{
	private:
		string capital;
		int code;
	
	public:
	    England(string capital, int code)
	    {
	    	this->capital = capital;
	    	this->code = code;
	    }
	    void getCapital(){
	    	cout << capital << endl;
	    }
};

int main(){
    France france = France("Paris", 1);
    Germany germany = Germany("Berlin", 2);
    England england = England("London", 3);
    
    france.getLandmark();
    germany.getLeader();
    france.getCapital();
    germany.getCapital();
    england.getCapital();
    
}
```

<br/>

__출력 결과__

<br/>

> Effel Tower <br/>
> Merkel <br/>
> Paris <br/>
> Berlin <br/>
> London <br/>

<br/>

위의 예제는 France, Germay, England라는 3개의 객체를 생성해 결과를 출력했다.<br/>
각각의 멤버 변수와 함수는 조금씩 다르지만 공통적인 부분도 존재한다.<br/>

<br/>

캡슐화를 사용한다면 공통적인 멤버 변수를 하나로 묶어 main 함수의 길이를 줄일 수 있다. <br/>

<br/>

```c++
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class France
{
	private:
		string capital;
		int code;
		string landmark = "Effel Tower";
	
	public:
	    France(string capital, int code)
	    {
	    	this->capital = capital;
	    	this->code = code;
	    }
	    void getCapital(){
	    	cout << capital << endl;
	    }
	    void getLandmark(){
	    	cout << landmark << endl;
	    }
};

class Germany
{
	private:
		string capital;
		int code;
		string leader = "Merkel";
	
	public:
	    Germany(string capital, int code)
	    {
	    	this->capital = capital;
	    	this->code = code;
	    }
	    void getCapital(){
	    	cout << capital << endl;
	    }
	    void getLeader(){
	    	cout << leader << endl;
	    }
};

class England
{
	private:
		string capital;
		int code;
	
	public:
	    England(string capital, int code)
	    {
	    	this->capital = capital;
	    	this->code = code;
	    }
	    void getCapital(){
	    	cout << capital << endl;
	    }
};

class Europe
{
	private:
		France france = France("Paris", 1);
    	Germany germany = Germany("Berlin", 2);
    	England england = England("London", 3);
    public:
    	void getCapital(){
    		france.getCapital();
    		germany.getCapital();
    		england.getCapital();
    	}
    	France getFrance(){ return france; }
    	Germany getGermany(){ return germany; }
    	England getEngland(){ return england; }
};

int main(){
	
	Europe europe = Europe();
	europe.getFrance().getLandmark();
  europe.getGermany().getLeader();
  europe.getCapital();
    
}
```

<br/>

__출력 결과__

<br/>

> Effel Tower <br/>
> Merkel <br/>
> Paris <br/>
> Berlin <br/>
> London <br/>

<br/>

이와 같이 Europe이라는 객체를 활용하게 된다면, 클래스를 계속 선언하고 함수를 연이어 선언하는 부담을 덜어준다.<br/>
해당 로직을 다른 클래스에 캡슐화하여 메인 함수에서의 동작을 줄인다.<br/>

<br/>
<br/>

## 2) Friend, Static, Const

<br/>

### 2-1) Friend

<br/>
<br/>

### 2-2) Static

<br/>
<br/>

### 2-3) Const

<br/>
<br/>
