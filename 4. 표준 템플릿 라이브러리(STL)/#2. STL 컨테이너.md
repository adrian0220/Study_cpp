# 2. STL 컨테이너 

<br/>
<br/>

## 1) 시퀀스 컨테이너 (Sequence Container)?

<br/>

데이터를 선형으로 저장하며, 특별한 제약이나 규칙이 없는 가장 일반적인 컨테이너 <br/>
삽입된 요소의 순서가 그대로 유지<br/>

<br/>

- vector, deque, list, forwad_list 등 <br/>

<br/>

__시퀀스 컨테이너의 요구 사항__ 


<br/>

1. 모든 요소가 직선 순서대로 배치되어 있어야 한다. <br/>
첫 번째 요소와 마지막 요소를 제외한 나머지 요소들은 반드시 앞뒤로 인접한 요소를 하나씩 가지고 있어야 한다. <br/>

<br/> 

2. 반복자가 최소한 순방향 반복자(forward iterator) 이상이어야 한다. <br/>
이것은 반복자가 이동할 때마다 요소들의 순서가 변하지 않음을 보장해 준다. <br/>

<br/> 

3. 시퀀스 컨테이너의 요소들은 명확한 순서를 가지므로, 특정 위치를 참조하는 연산이 가능해야 한다. <br/>

<br/>
<br/>

## 1-1) 벡터 (Vector)

<br/>

데이터를 선형으로 저장하는 가장 기본적인 시퀀스 컨테이너 <br/>

<br/>

__Vector의 특징__

<br/>

- 동적 배열의 클래스 템플릿 표현한다. <br/>
- 벡터 객체는 요소가 추가되거나 삭제될 때마다 자동으로 메모리를 재할당하여 크기를 동적으로 변경한다.<br/>
- vector 헤더 파일에 정의되어 있으므로 반드시 미리 선언해주어야 한다. <br/>

<br/>

__Vector의 사용__

<br/>

Vector를 사용하기 위해선 헤더 파일을 선언해야 한다. <br/>

<br/>

```c++
#include <vector>
```

<br/>

선형으로 데이터를 선언해야 하고, 각 데이터에 자유롭게 접근하고 싶은 경우 Vector를 사용한다.

<br/>

__Vector의 선언__

<br/>

벡터의 기본 선언 방법은 아래와 같다. <br/>

<br/>

> vector<템플릿인수> 객체이름(생성자인수);

<br/>

Vector를 선언하는 방법은 아래의 방법이 있다. <br/>

<br/>

```c++
vector<int> v1;                 // vector 선언 (모든 벡터요소 0으로 초기화)
vector<int> v2 = {10, 20, 30};  // vector 객체의 선언 및 초기화
vector<int> v3(4);              // int형 백터 생성 후 크기를 4로 할당(모든 백터요소 0으로 초기화)
vector<vector<int>> v4;         // 2차원 백터 생성
vector<int> v5(5, 2);           // 크기가 5이고 요소가 2인 벡터 생성
- 2로 초기화된 5개의 원소를 가지는 vector v를 생성합니다
```

<br/>

다음은 위의 방법으로 벡터를 선언하고 출력한 결과다.<br/>

<br/>

```c++
#include <iostream>
#include <vector>
using namespace std;

int main() {
	
	vector<int> v(5, 2);
	for (int i = 0; i < v.size(); i++)
	cout << v[i] << " ";
	return 0;
}
```

<br/>

>   2 2 2 2 2

<br/>
<br/>

__Vector 함수__

<br/>

- v.assign(int a, int b) : 해당 범위 a의 값을 b로 초기화 <br/>

<br/>

벡터의 값을 새로 초기화 한다.

<br/>

```c++
#include <iostream>
#include <vector>
using namespace std;

int main() {
	
	vector<int> v(5, 2);
	v.assign(2, 10);
	
	for (int i = 0; i < v.size(); i++)
	cout << v[i] << " ";
	
	return 0;
}
```

<br/>

> 10 10 <br/>

<br/>

- v.at(idx) : idx번째 원소를 참조 (속도는 느리지만 범위 점검) <br/>
- v[idx] : idx번째 원소를 참조 (범위 점검 안해서 속도 빠름) <br/>

<br/>

```c++
#include <iostream>
#include <vector>
using namespace std;

int main() {
	
	vector<int> v = {10, 20, 30, 40};
	
	cout << v.at(5) << " ";		// runtime error!!
	cout << v[5] << " ";		// 0 으로 출력

	return 0;
}
```

<br/>

참조 관련 <br/>

- v.front() : 첫번째 원소를 참조 <br/>
- v.back() : 마지막 원소를 참조 <br/>

<br/>

삽입 및 삭제 <br/>

<br/>

- v.clear() : 모든 원소를 제거, 메모리는 남아있다. (size = 0, capacity 유지) <br/>
- v.push_back(element) : 마지막 원소 뒤에 원소 element 삽입 <br/>
- v.pop_back() : 마지막 원소를 제거 <br/> 
- v.begin() : 첫번째 원소 (주로, iterator와 사용) <br/>
- v.end() : 마지막의 다음 원소 (주로, iterator와 사용) <br/>

<br/>

크기(size) 및 메모리 할당(capacity) <br/>

<br/>

- v.reserve(n) : vector의 capacity를 n으로 조정 <br/>
- v.resize(n) : vector의 size를 n으로 변경 <br/>
- v.resize(n,3) : vector의 size를 n으로 변경하고, 더 커진 경우 인자를 3으로 초기화 <br/>
- v.size() : 원소의 갯수를 반환 <br/>
- v.capacity() : 할당된 공간의 크기를 반환 <br/>

<br/>

기타 <br/>

<br/>

- v2.swap(v1) : v1과 v2의 원소 내용과 capacity를 바꿈 <br/> 
- v.insert(a, b, c) : a번째 위치부터 b개의 원소 4를 삽입 (a+1원소들은 뒤로 밀림) <br/>
- v.insert(a, b) : a번째 위치에 값 3을 삽입 <br/>
- v.erase(iter) : iter가 가리키는 원소를 제거 (capacity 유지) <br/>
- v.empty() : vector가 비었으면 true 리턴 (size = 0) <br/>

<br/>

__Vector 예제__

<br/>

```c++
#include <iostream>
#include <vector>
using namespace std;

int main() {
	
	vector<int> v = {10, 20, 30, 40}; // vector 객체의 선언 및 초기화
	cout << "v size is " << v.size() << endl;

	v.push_back(50);
	cout << "v size is " << v.size() << endl;
	cout << "v[4] = " << v[4] << endl;

    return 0;

}
```

<br/>

> v size is 4 <br/>
> v size is 5 <br/>
> v[4] = 50 <br/>

<br/>
<br/>

## 1-2) 덱 (Deque)
