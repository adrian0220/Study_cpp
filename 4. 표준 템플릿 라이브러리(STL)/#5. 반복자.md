# 5. 반복자

<br/>
<br/>

## 5-1) 입력 반복자(Input Iterator)?

<br/>

가장 단순한 형태의 반복자로 컨테이너로부터 값을 읽는 데 사용 <br/>

<br/>

1. 증가 연산자( ++ )를 사용하여 순방향으로만 이동 <br/>
2. 참조 연산자( * )를 사용하여 반복해서 요소 참조 가능 <br/>
3. 컨테이너로부터 값을 읽을 수 있지만, 변경할 수 는 없다. <br/>

<br/>

입력 반복자의 경우 find()을 통해서 요소에 참조하고, find 함수의 원형은 다음과 같다. <br/>

```c++
template <class InputIterator, class T>
InputIterator find (InputIterator first, InputIterator last, const T& value) {   
  while (first != last && *first != value)      
  ++first;   
  return first; 
}
```

<br/>
<br/>

## 5-2) 출력 반복자(Output Iterator)?

<br/>

컨테이너의 값을 변경하는 데 사용 <br/>

<br/>

1. 증가 연산자( ++ )를 사용하여 순방향으로만 이동 <br/>
2. 참조 연산자( * )를 사용하여 단 한번만 요소 참조 가능 <br/>
3. 컨테이너로부터 값을 변경할 수 있지만, 읽지는 못한다. <br/>

<br/>

출력 반복자를 통해 한 컨테이너에서 다른 컨테이너로 값을 복사하는 Copy() 함수를 사용하고, Copy 함수의 원형은 다음과 같다. <br/>

```c++
template <class InputIterator, class OutputIterator>
OutputIterator copy(InputIterator first, InputIterator last, OutputIterator result) {
  while (first != last)
  *result++ = *first++;
  return result;
}
```

<br/>
<br/>

## 5-3) 순방향 반복자(Forward Iterator)?

<br/>

입출력이 모두 가능한 반복자 <br/>

<br/>

1. 증가 연산자( ++ )를 사용하여 순방향으로만 이동 <br/>
2. 참조 연산자( * )를 사용하여 여러번 같은 요소를 참조하거나 변경이 가능 <br/>
3. 입력 반복자와 출력 반복자의 기능 모두 포함 <br/>

<br/>

특정 값을 찾아 다른 값으로 변경하는 Replace() 함수의 원형은 다음과 같다. <br/>

```c++
template <class ForwardIterator, class T>
void replace (ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value) {
  while (first != last) {       
    if (*first == old_value)          
    *first = new_value;
    ++first;
  } 
}
```

<br/>
<br/>

## 5-4) 양방향 반복자(Bidirectional Iterator)?

<br/>

양방향으로 입출력이 모두 가능한 반복자 <br/>

<br/>

1. 증가 연산자( ++ )를 사용하여 순방향으로만 이동이 가능하고, 감소 연산자( -- )를 사용하여 역방향으로 이동도 가능하다 <br/>
2. 참조 연산자( * )를 사용하여 여러번 같은 요소를 참조하거나 변경이 가능 <br/>
3. 순방향 반복자의 기능 모두 포함 <br/>

<br/>

특정 컨테이너의 모든 값을 거꾸로 새로운 컨테이너에 옮기는 Reverse() 함수의 원형은 다음과 같다. <br/>

```c++
template <class BidirectionalIterator, class OutputIterator>
OutputIterator reverse_copy (BidirectionalIterator first, BidirectionalIterator last, OutputIterator result) {
  while (first != last)
  *result++ = *--last;
  return result; 
}
```

<br/>
<br/>

## 5-5) 임의 접근 반복자(Random Access Iterator)?

<br/>

최상위 레벨의 반복자로서 가장 많은 기능을 제공 반복자 <br/>

<br/>

1. 첨자 연산자([])를 통해 임의의 요소에 접근 <br/>
2. 양방향 반복자의 기능 모두 포함 <br/>

<br/>

특정 컨테이너의 모든 값을 거꾸로 새로운 컨테이너에 옮기는 Reverse() 함수의 원형은 다음과 같다. <br/>

```c++
template <class RandomAccessIterator>
void mixup(RandomAccessIterator first, RandomAccessIterator last) {
   while (first < last) {
      iter_swap(first, first + randomInteger(last - first));
      ++first;
   }
}
```

<br/>
<br/>

## 5-6) 반복자 계층

<br/>

STL에서 반복자는 계층적으로 분류된다. <br/>
예를 들어, 순방향 반복자는 입력 반복자와 출력 반복자의 모든 기능을 포함한다. <br/>

<br/>

다음은 C++ 반복자 계층 구조에 대한 예시다. <br/>

<br/>

![](https://github.com/adrian0220/Study_cpp/blob/main/_src/20210903_2.GIF)

<br/>
<br/>
